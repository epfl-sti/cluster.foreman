#!/usr/bin/perl -w

use strict;

=head1 NAME

dockerer - Build and run the things under docker/

=head1 SYNOPSIS

   dockerer plan
   dockerer build [--scratch|--saved=<tarname>] <clustername>
   dockerer run <clustername>
   dockerer backup <clustername>

Where C<target> is one of "foreman-base" or "foreman"

=head1 DESCRIPTION

Dockerer runs docker, as the name implies, and also handles the moving
parts that are close by (specifically, networking and persistent data).

=head2 Plan

The "plan" phase consists of downloading as much things as can be. The
result is a Docker image called C<epflsti/foreman-base> that has no
personalization built-in and can be re-used in any number of clusters,
uploaded to a private Docker registry and so on.

=head2 Build

The "build" phase consists of personalizing the "plan" image to suit a
particular cluster and network environment. Personalization
information comes from the previous image if any, and the
C<foreman-installer-answers.yaml> file produced by C<../configure.pl>.
The result is an image called epflsti/foreman-$FQDN, where $FQDN is
the fully-qualified host name of the Foreman instance (as seen from
within the container's own DNS server).

=head2 Run

The "run" phase consists of instantiating epflsti/foreman-$FQDN and
 running supervisord inside the container so created.

=head2 Data Upgrade

Unless the C<--scratch> flag is passed, the L</Build> operation
attempts to save and re-use the data of any existing, L</Run>ning
Docker container.

=cut

use FindBin qw($Bin);
use lib "$Bin/../lib";
use autodie qw(:all);
use Docopt;
use Pod::Usage;
use Try::Tiny;
use EPFLSTI::Interactive;

chdir("$Bin/..");

our $opts;
try {
  $opts = docopt();
} catch {
  pod2usage();
};

if ($opts->{plan}) {
  plan();
} elsif ($opts->{build}) {
  build(Foreman->load($opts->{'<clustername>'}));
} elsif ($opts->{run}) {
  run(Foreman->load($opts->{'<clustername>'}));
} elsif ($opts->{backup}) {
  backup(Foreman->load($opts->{'<clustername>'}));
} else {
  pod2usage();
}

sub plan {
  system("cd '$Bin/foreman-base' && docker build -t epflsti/foreman-base .");
}

sub build {
  my ($foreman) = @_;
  plan();
  my $answers_yaml = "$Bin/../foreman-installer-answers.yaml";

  my $tarname_to_restore="";
  if ($opts->{"--saved"}) {
    die "--saved must be a relative path (no slashes)" if
      ($opts->{"--saved"} =~ m|/|);
    $tarname_to_restore = $opts->{"--saved"};
    die "File does not exist: $tarname_to_restore" unless (-f $tarname_to_restore);
  } elsif ($foreman->container_exists) {
    $tarname_to_restore = backup($foreman);
    system("set -x; tar --to-stdout -xvf $tarname_to_restore etc/foreman/foreman-installer-answers.yaml > foreman-installer-answers.yaml");
  } elsif (! -f $answers_yaml) {
    system("$Bin/../configure.pl");
  }

  my @shellvars = ($Bin,
                   $foreman->cluster_name(),
                   $foreman->container_name(), $foreman->image_name(),
                   foreman_phys_internal_iface(),
                   foreman_ipaddr(), foreman_netmask(), $tarname_to_restore);
  system(sprintf(<<'DOCKER_PERSONALIZE', @shellvars));
Bin=%s
clustername=%s
container_name=%s
image_name=%s
foreman_phys_internal_iface=%s
foreman_ipaddr=%s
foreman_netmask=%s
docker rm $container_name-INITIAL >/dev/null 2>&1
set -e -x
(sleep 10; $Bin/foreman-base/pipework/pipework br.4priv \
           $container_name-INITIAL $foreman_ipaddr/$foreman_netmask) &
docker run --name=$container_name-INITIAL -h $container_name \
    -v "$Bin/..":/cluster.foreman \
    --label=ch.epfl.sti.foreman.built_for_clustername=$clustername \
    -it epflsti/foreman-base \
    bash -c 'tarname=%s; set -e -x; /usr/local/bin/pipework --wait -i eth1 && \
             . /cluster.foreman/docker/scripts/build'
containerid=$(docker ps -q -a \
  --filter="label=ch.epfl.sti.foreman.built_for_clustername=$clustername" \
  | head -1)
imageid=$(docker commit $containerid)
containerid2=$(docker create --entrypoint=/usr/bin/supervisord $imageid)
docker commit $containerid2 $image_name
DOCKER_PERSONALIZE
}

sub run {
  my ($foreman) = @_;

  my $cluster_name = $foreman->cluster_name();
  my $container_name = $foreman->container_name();
  my $image_name = $foreman->image_name();
  my $foreman_ipaddr = foreman_ipaddr();
  my $foreman_netmask = foreman_netmask();
  my $foreman_phys_internal_iface = foreman_phys_internal_iface();

  if (my $container_details = $foreman->container_details) {
    my $container_created = $container_details->[0]->{Created};
    my $image_created = $foreman->image_details->[0]->{Created};
    if ($image_created ge $container_created) {
      return unless prompt_yn(<<"CONFIRM");

About to resume from image $image_name, created $image_created.

All changes since that date will be lost.

Are you sure?
CONFIRM
    } else {
      return unless "Yes, I want to lose data" eq prompt_user(<<"CONFIRM");

About to resume from image $image_name, created $image_created.

WARNING: This image was created AFTER container $container_name, itself
dated $container_created.

It is HIGHLY RECOMMENDED to first run

  $0 build ${cluster_name}

IF YOU PROCEED NOW, THE FOREMAN STATE WILL BE LOST!

Please confirm by typing "Yes, I want to lose data" and pressing Return.
CONFIRM
    }
  }

  # Ensuring that br.4priv is set up correctly is done by Puppet
  # (in fully operational mode) and by install-provisioning-server.sh
  # (during install)
  system(<<"BRIDGE_AND_DOCKER_RUN");
set -e -x
# TODO: This is just ugly.
(sleep 10; $Bin/foreman-base/pipework/pipework br.4priv \\
           $container_name $foreman_ipaddr/$foreman_netmask) & \\
docker run -it --volumes-from=$container_name-INITIAL \\
    --name=$container_name -h $container_name \\
    --dns=127.0.0.1 \\
    -v "$Bin/..":/cluster.foreman \\
    $image_name
BRIDGE_AND_DOCKER_RUN
}

sub backup {
  my ($foreman) = @_;
  my $container_name = $foreman->container_name();

  require POSIX;
  my $date = POSIX::strftime("%Y%m%d%H%M%S", localtime(time));
  my $tarname = "backup-${container_name}-$date.tar";
  system("set -x; docker export $container_name > $tarname");
  warn("Backup to $tarname successful.\n");
  return $tarname;
}

# TODO: parse foreman-installer-answers.yaml to figure out these:
sub foreman_ipaddr { "192.168.10.2" }
sub foreman_netmask { "24" }
sub foreman_phys_internal_iface { "eth1" }

package Foreman;

use Net::Domain qw(hostdomain);
use JSON;

sub load {
  my ($class, $clustername) = @_;
  return bless { clustername => $clustername }, $class;
}

sub cluster_name { shift->{clustername} }

sub container_name {
  my ($self) = @_;
  my $clustername = $self->cluster_name();
  if ($clustername =~ m/\./) {
    return $clustername;
  } else {
    return "${clustername}." . hostdomain;
  }
}

sub image_name {
  my ($self) = @_;
  my $container_name = $self->container_name();
  return "epflsti/foreman-$container_name";
}

sub container_exists {
  my ($self) = @_;

  my $container_name = $self->container_name;
  return `docker ps -q --filter='name=$container_name'`;
}

sub container_details {
  my ($self) = @_;
  return unless (my $id = $self->container_exists);
  return decode_json(scalar(`docker inspect $id`));
}

sub image_details {
  my ($self) = @_;
  my $image_name = $self->image_name();
  return decode_json(scalar(`docker inspect $image_name`));
}
